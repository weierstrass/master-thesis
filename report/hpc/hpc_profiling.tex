\section{Profiling}
In the development phase of optimising a code, a most valuable tool is
a profiler. Basically it is a program that allows for analysing the
program as it runs, e.g. to give information of which instructions are
executed, if the CPU stalls or if and when cache misses are
present. This information is also connected to the source code which
gives easy access for the developer to correct eventual performance
issues.

A popular profiler used on UNIX systems is \texttt{gprof}. In this
work, it is used to determine which routines that most contribute to
the total execution time. It is in those routines that a code
optimisation is most profitable. In order to be able to profile with
\texttt{gprof}, the code must be compiled with additional compiler
flags (\texttt{-pg} with \texttt{gcc}). This profilable program will
run slower than a program compiled without profiling flags, it is thus
important to not forget to compile the ``finished'' code without
profiling flags. Below is an example of some output given by
\texttt{gprof} when profiling the Navier-Stokes LBM implementation:

\begin{verbatim}
  %   cumulative   self                         
 time   seconds   seconds    calls  name    
 40.98      1.61     1.61 40000000  BGKNS::get1moment(int, int, double*)
 30.54      2.81     1.20 40000000  BGKNS::fEq(double, double*, double*)
 10.69      3.23     0.42 40000000  BGKNS::get0moment(int, int)
 10.18      3.63     0.40     1000  StreamD2Q9::stream()
 ...
\end{verbatim}
for brevity, only the output of most time consuming routines are
shown. 
%extra time

\subsection{Memory specific profiling}

valgrind
